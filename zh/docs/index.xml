<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on 区块链入门指南</title><link>https://guide.pseudoyu.com/zh/docs/</link><description>Recent content in Docs on 区块链入门指南</description><generator>Hugo</generator><language>zh</language><atom:link href="https://guide.pseudoyu.com/zh/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Ethereum MPT(Merkle Patricia Tries) 详解</title><link>https://guide.pseudoyu.com/zh/docs/ethereum/blockchain_ethereum_mpt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/ethereum/blockchain_ethereum_mpt/</guid><description>&lt;h1 id="ethereum-mptmerkle-patricia-tries-详解"&gt;
 Ethereum MPT(Merkle Patricia Tries) 详解
 &lt;a class="anchor" href="#ethereum-mptmerkle-patricia-tries-%e8%af%a6%e8%a7%a3"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;最近接到了一个工作任务，将项目智能合约状态树中的数据结构从红黑树改为字典树，并对比一下两个数据结构的性能，Trie 主要参照的是 Ethereum 官方的 Java 实现 &lt;a href="https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie"&gt;ethereum/ethereumj&lt;/a&gt;，而红黑树则是自己实现，本文则是对两个数据结构的理论和实际表现对比的记录。&lt;/p&gt;
&lt;h2 id="数据结构"&gt;
 数据结构
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="red-black-tree---红黑树"&gt;
 Red-Black Tree - 红黑树
 &lt;a class="anchor" href="#red-black-tree---%e7%ba%a2%e9%bb%91%e6%a0%91"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;红黑树是一种近似平衡的二叉查找树，含有红黑结点，能够确保任何一个结点的左右子树高度差小于两倍。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/red_black_tree_2.png" alt="red_black_tree_2" /&gt;&lt;/p&gt;
&lt;h4 id="性质"&gt;
 性质
 &lt;a class="anchor" href="#%e6%80%a7%e8%b4%a8"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;必须满足以下五个性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结点为红色或黑色&lt;/li&gt;
&lt;li&gt;根结点为黑色&lt;/li&gt;
&lt;li&gt;叶子结点（NIL）为黑色&lt;/li&gt;
&lt;li&gt;每个红色节点的两个子结点为黑色&lt;/li&gt;
&lt;li&gt;任意一个结点到每个叶子结点的路径都包含相同数量的黑色结点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;红黑树并不是完美平衡的，但是左子树和右子树的层数是相等的，因此，也成为黑色完美平衡。因为是近似平衡的，所以旋转的频次会降低，维护成本下降，时间复杂度维持在 LogN。&lt;/p&gt;
&lt;h4 id="操作"&gt;
 操作
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;红黑树主要通过三种操作来保持自平衡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左旋&lt;/li&gt;
&lt;li&gt;右旋&lt;/li&gt;
&lt;li&gt;变色&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="与-avl-的对比"&gt;
 与 AVL 的对比
 &lt;a class="anchor" href="#%e4%b8%8e-avl-%e7%9a%84%e5%af%b9%e6%af%94"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;AVL 提供了更快的查找操作（因为完美平衡）&lt;/li&gt;
&lt;li&gt;红黑树提供了更快的插入和删除操作&lt;/li&gt;
&lt;li&gt;AVL 存储的结点信息更多（平衡因子与高度），因此占存储空间更大&lt;/li&gt;
&lt;li&gt;读操作多、写操作少的时候用 AVL 更合适，多用于数据库；当写操作较多时一般使用红黑树，简洁好实现，多用于各类高级语言的库中，如 map、set 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="代码实现"&gt;
 代码实现
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;因为红黑树较为复杂，实现代码上传至 GitHub 供学习查看。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/pseudoyu/Red_Black_Tree_Java"&gt;pseudoyu/Red_Black_Tree_Java - GitHub&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Ethereum 核心技术解读</title><link>https://guide.pseudoyu.com/zh/docs/ethereum/blockchain_ethereum_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/ethereum/blockchain_ethereum_basic/</guid><description>&lt;h1 id="ethereum-核心技术解读"&gt;
 Ethereum 核心技术解读
 &lt;a class="anchor" href="#ethereum-%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e8%a7%a3%e8%af%bb"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;比特币作为一种去中心化的数字货币，是极其成功的，但受限于比特币脚本（非图灵完备，只能处理一些简单的逻辑），并不能处理很复杂的业务。而&lt;code&gt;Ethereum&lt;/code&gt;引入了智能合约，使去中心化的概念能够应用于更丰富的应用场景，因此也被称为区块链 2.0。本文将对以太坊核心技术进行解读，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="ethereum-系统"&gt;
 Ethereum 系统
 &lt;a class="anchor" href="#ethereum-%e7%b3%bb%e7%bb%9f"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;2014 年 1 月，俄罗斯开发者 Vitalik Buterin 发布了以太坊白皮书并成立团队，旨在创造一个集成更通用的脚本语言的区块链平台。其中一位成员 Dr. Gavin Wood 发布了一份黄皮书，涉及&lt;code&gt;Ethereum Virtual Machin(EVM)&lt;/code&gt;以太坊虚拟的相关技术，这就是&lt;code&gt;Ethereum&lt;/code&gt;的诞生。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/ethereum_overview.png" alt="ethereum_overview" /&gt;&lt;/p&gt;
&lt;p&gt;简单来说，&lt;code&gt;Ethereum&lt;/code&gt;是一个开源的去中心化系统，使用区块链来存储系统状态变化，因此也被称为“世界计算机”；它支持开发者在区块链上部署运行不可变的程序，称为智能合约，因此可以支持广泛的应用场景；它使用数字货币&lt;code&gt;Ether&lt;/code&gt;来衡量系统资源消耗，激励更多人参与&lt;code&gt;Ethereum&lt;/code&gt;系统建设。&lt;/p&gt;
&lt;h3 id="去中心化应用-dapp"&gt;
 去中心化应用 DApp
 &lt;a class="anchor" href="#%e5%8e%bb%e4%b8%ad%e5%bf%83%e5%8c%96%e5%ba%94%e7%94%a8-dapp"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;狭义来说，DApp 其实就是一个集成了用户界面、支持智能合约、运行于以太坊区块链上的应用。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/ethereum_architecture.png" alt="ethereum_architecture" /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，&lt;code&gt;Ethereum&lt;/code&gt;应用实例部署在区块链网络上（智能合约运行于区块链虚拟机中），而 Web 程序只需要通过&lt;code&gt;Web3.js&lt;/code&gt;对区块链网络进行&lt;code&gt;RPC&lt;/code&gt;远程调用，这样用户就可以通过浏览器（DApp 浏览器或 MetaMask 等插件工具）访问去中心化服务应用了。&lt;/p&gt;
&lt;h3 id="账本"&gt;
 账本
 &lt;a class="anchor" href="#%e8%b4%a6%e6%9c%ac"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Ethereum&lt;/code&gt;区块链是一个去中心化的账本（数据库），网络中的所有交易都会存储在区块链中，所有节点都要本地保存一份数据，并且确保每一笔交易的可信度；所有的交易都是公开且不可篡改的，网络中的所有节点都可以查看和验证。&lt;/p&gt;
&lt;h3 id="账户"&gt;
 账户
 &lt;a class="anchor" href="#%e8%b4%a6%e6%88%b7"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;当我们需要登录一个网站或系统（比如邮箱）时，往往需要一个帐号和一个密码，密码通过加密算法以暗文的形式存储在中心化的数据库中。然而，以太坊是一个去中心化的系统，那是怎么生成账户的呢？&lt;/p&gt;
&lt;p&gt;和比特币系统原理类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先生成一个仅有自己知道的私钥，假设为&lt;code&gt;sk&lt;/code&gt;，采用&lt;code&gt;ECDSA(Elliptic Curve Digital Signature Algorithm)&lt;/code&gt;椭圆曲线算法生成对应的公钥&lt;code&gt;pk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;采用&lt;code&gt;keccak256&lt;/code&gt;算法对公钥&lt;code&gt;pk&lt;/code&gt;求哈希值&lt;/li&gt;
&lt;li&gt;截取后 160 位作为以太坊的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户的私钥和地址一起组成了以太坊的账户，可以存储余额、发起交易等（比特币的余额是通过计算所有的&lt;code&gt;UTXO&lt;/code&gt;得到的，而不是像以太坊一样存储在账户中）。&lt;/p&gt;
&lt;p&gt;其实&lt;code&gt;Ethereum&lt;/code&gt;账户分为两种类型，上述方式生成的叫&lt;code&gt;Externally Owned Accounts(EOA)&lt;/code&gt;，外部账户，也就是常规用户拥有的账户，主要是用来发送/接收&lt;code&gt;Ether&lt;/code&gt;代币或者向智能合约发送交易（即调用智能合约）。&lt;/p&gt;
&lt;p&gt;而另一种则是&lt;code&gt;Contract Accounts&lt;/code&gt;，合约账户，不同于外部账户，这种账户是没有对应的私钥的，而是在部署合约的时候生成的，存储智能合约代码。值得注意的是，合约账户必须要被外部账户或者其他合约调用才能够发送或接收&lt;code&gt;Ether&lt;/code&gt;，而不能自己主动执行交易。&lt;/p&gt;
&lt;h3 id="钱包"&gt;
 钱包
 &lt;a class="anchor" href="#%e9%92%b1%e5%8c%85"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;存储和管理&lt;code&gt;Ethereum&lt;/code&gt;账户的软件/插件称为钱包，提供了诸如交易签名、余额管理等功能。钱包生成主要有两种方式，非确定性随机生成或根据随机种子生成。&lt;/p&gt;</description></item><item><title>Hyperledger Fabric Go SDK 事件分析</title><link>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_gosdk_event/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_gosdk_event/</guid><description>&lt;h1 id="hyperledger-fabric-go-sdk-事件分析"&gt;
 Hyperledger Fabric Go SDK 事件分析
 &lt;a class="anchor" href="#hyperledger-fabric-go-sdk-%e4%ba%8b%e4%bb%b6%e5%88%86%e6%9e%90"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;最近在做跨链适配器，需要在一条本地链上利用 Go SDK 来连接 fabric 网络，并监听事件，所以对 fabric 所支持的事件与 SDK 所提供的监听方法做一下汇总。&lt;/p&gt;
&lt;h2 id="fabric-事件"&gt;
 Fabric 事件
 &lt;a class="anchor" href="#fabric-%e4%ba%8b%e4%bb%b6"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="事件类型"&gt;
 事件类型
 &lt;a class="anchor" href="#%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/hyperledger_fabric_application_interact.png" alt="hyperledger_fabric_application_interact" /&gt;&lt;/p&gt;
&lt;p&gt;事件是客户端与 Fabric 网络进行交互的一种方式，如上图所示，事件主要由 Ledger 和存有链码合约的容器触发。Fabric 共支持四种事件形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BlockEvent 监控新增到 fabric 上的块时使用&lt;/li&gt;
&lt;li&gt;ChaincodeEvent 监控链码中发布的事件时使用，也就是用户自定义事件&lt;/li&gt;
&lt;li&gt;TxStatusEvent 监控节点上的交易完成时使用&lt;/li&gt;
&lt;li&gt;FilteredBlockEvent 监控简要的区块信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Fabric Go SDK 中则通过以下几种事件监听器进行操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;func (c *Client) RegisterBlockEvent(filter ...fab.BlockFilter) (fab.Registration, &amp;lt;-chan *fab.BlockEvent, error)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func (c *Client) RegisterChaincodeEvent(ccID, eventFilter string) (fab.Registration, &amp;lt;-chan *fab.CCEvent, error)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func (c *Client) RegisterFilteredBlockEvent() (fab.Registration, &amp;lt;-chan *fab.FilteredBlockEvent, error)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func (c *Client) RegisterTxStatusEvent(txID string) (fab.Registration, &amp;lt;-chan *fab.TxStatusEvent, error)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而当监听完成后需要通过 &lt;code&gt;func (c *Client) Unregister(reg fab.Registration)&lt;/code&gt; 来取消注册并移除事件通道&lt;/p&gt;</description></item><item><title>Hyperledger Fabric 网络与安全体系浅析</title><link>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_network/</guid><description>&lt;h1 id="hyperledger-fabric-网络与安全体系浅析"&gt;
 Hyperledger Fabric 网络与安全体系浅析
 &lt;a class="anchor" href="#hyperledger-fabric-%e7%bd%91%e7%bb%9c%e4%b8%8e%e5%ae%89%e5%85%a8%e4%bd%93%e7%b3%bb%e6%b5%85%e6%9e%90"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;上一篇文章《&lt;a href="https://www.pseudoyu.com/zh/2021/03/20/blockchain_hyperledger_fabric_structure/"&gt;Hyperledger Fabric 架构详解&lt;/a&gt;》对&lt;code&gt;Fabric&lt;/code&gt;的架构和工作原理进行了详细的解读与分析，那作为一个企业级的区块链系统，它是如何根据复杂的业务需求搭建网络，在运行过程中存在哪些安全问题，以及&lt;code&gt;Fabric&lt;/code&gt;是如何从机制上进行预防的呢？&lt;/p&gt;
&lt;p&gt;本文将通过实例阐释一个简化版的企业&lt;code&gt;Fabric&lt;/code&gt;网络是如何构建的，并对其网络与安全体系进行分析，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="hyperledger-fabric-网络"&gt;
 Hyperledger Fabric 网络
 &lt;a class="anchor" href="#hyperledger-fabric-%e7%bd%91%e7%bb%9c"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="hyperledger-fabric-应用场景实例"&gt;
 Hyperledger Fabric 应用场景实例
 &lt;a class="anchor" href="#hyperledger-fabric-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e5%ae%9e%e4%be%8b"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;h4 id="业务角色"&gt;
 业务角色
 &lt;a class="anchor" href="#%e4%b8%9a%e5%8a%a1%e8%a7%92%e8%89%b2"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;假设有一个采用&lt;code&gt;Fabric&lt;/code&gt;系统的应用场景里。&lt;/p&gt;
&lt;p&gt;有 4 个组织&lt;code&gt;R1&lt;/code&gt;, &lt;code&gt;R2&lt;/code&gt;, &lt;code&gt;R3&lt;/code&gt;和&lt;code&gt;R4&lt;/code&gt;，&lt;code&gt;R4&lt;/code&gt;是网络启动者，&lt;code&gt;R1&lt;/code&gt;和&lt;code&gt;R4&lt;/code&gt;共同担任网络管理员角色。&lt;/p&gt;
&lt;p&gt;系统设置了 2 个通道，分别为&lt;code&gt;C1&lt;/code&gt;和&lt;code&gt;C2&lt;/code&gt;。&lt;code&gt;R1&lt;/code&gt;和&lt;code&gt;R2&lt;/code&gt;使用&lt;code&gt;C1&lt;/code&gt;通道，&lt;code&gt;R2&lt;/code&gt;和&lt;code&gt;R3&lt;/code&gt;使用&lt;code&gt;C2&lt;/code&gt;通道。&lt;/p&gt;
&lt;p&gt;应用&lt;code&gt;A1&lt;/code&gt;属于组织&lt;code&gt;R1&lt;/code&gt;，于&lt;code&gt;C1&lt;/code&gt;通道运行；应用&lt;code&gt;A2&lt;/code&gt;属于组织&lt;code&gt;R2&lt;/code&gt;，同时于&lt;code&gt;C1&lt;/code&gt;通道和&lt;code&gt;C2&lt;/code&gt;通道运行；应用&lt;code&gt;A3&lt;/code&gt;属于组织&lt;code&gt;R3&lt;/code&gt;，于&lt;code&gt;C2&lt;/code&gt;通道运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P1&lt;/code&gt;、&lt;code&gt;P2&lt;/code&gt;和&lt;code&gt;P3&lt;/code&gt;分别是组织&lt;code&gt;R1&lt;/code&gt;、&lt;code&gt;R2&lt;/code&gt;和&lt;code&gt;R3&lt;/code&gt;的节点。&lt;/p&gt;
&lt;p&gt;排序节点由&lt;code&gt;O4&lt;/code&gt;提供，属于组织&lt;code&gt;R4&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="搭建过程"&gt;
 搭建过程
 &lt;a class="anchor" href="#%e6%90%ad%e5%bb%ba%e8%bf%87%e7%a8%8b"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;与真正的商业应用场景相比，角色和商业和逻辑都很简化，但很适合用来理解不同节点和角色之间的功能和交互。接下来，我将一步一步说明网络的搭建过程。&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;创建网络并添加网络管理员&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;每一个组织需要通过&lt;code&gt;MSP&lt;/code&gt;中的 CA 机构颁发的证书才能加入网络，因此，每个节点都需要有相应的 CA。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R4&lt;/code&gt;作为网络启动者，需要先配置网络并设立&lt;code&gt;O4&lt;/code&gt;排序节点！网络创建后，添加&lt;code&gt;R1&lt;/code&gt;作为网络管理员，因此，&lt;code&gt;R1&lt;/code&gt;和&lt;code&gt;R4&lt;/code&gt;可以对网络进行配置（&lt;code&gt;NC4&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/fabric_network_example_1.png" alt="fabric_network_example_1" /&gt;&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;定义联盟并创建通道&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;R1&lt;/code&gt;和&lt;code&gt;R2&lt;/code&gt;将通过&lt;code&gt;C1&lt;/code&gt;进行业务交互，因此需要在网络中定义联盟，因为现在&lt;code&gt;R1&lt;/code&gt;和&lt;code&gt;R4&lt;/code&gt;都可以对网络进行配置，因此都可以定义联盟。&lt;/p&gt;
&lt;p&gt;接着为这个联盟创建通道&lt;code&gt;C1&lt;/code&gt;（连接至排序服务&lt;code&gt;O4&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/fabric_network_example_2.png" alt="fabric_network_example_2" /&gt;&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;加入节点、部署智能合约与应用&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;P1&lt;/code&gt;节点加入已经建立的通道&lt;code&gt;C1&lt;/code&gt;，维护着一个账本&lt;code&gt;L1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这时候就可以在节点上安装和实例化智能合约了。&lt;code&gt;Fabric&lt;/code&gt;的智能合约是链码，把链码存储在节点的文件系统上称为安装智能合约，安装后还需要在特定的通道上启动和实例化链码，至此，应用可以发送交易 proposal 至背书节点了（需要遵守链码设置的背书策略）。&lt;/p&gt;
&lt;p&gt;如下图所示，&lt;code&gt;P1&lt;/code&gt;节点安装链码&lt;code&gt;S5&lt;/code&gt;并在通道&lt;code&gt;C1&lt;/code&gt;实例化后，就可以响应来自应用&lt;code&gt;A1&lt;/code&gt;的链码调用了;&lt;code&gt;P2&lt;/code&gt;节点安装链码&lt;code&gt;S5&lt;/code&gt;并在通道&lt;code&gt;C1&lt;/code&gt;实例化后，就可以响应来自应用&lt;code&gt;A2&lt;/code&gt;的链码调用了。&lt;/p&gt;
&lt;p&gt;通道中的每一个节点都是提交节点，可以接收新区块（来自排序节点）进行验证，并提交至账本；而部署了链码的一些节点则可以成为背书节点。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/fabric_network_example_4.png" alt="fabric_network_example_4" /&gt;&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;定义新联盟、创建新通道&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;在网络中定义新联盟并加入&lt;code&gt;C2&lt;/code&gt;通道。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/fabric_network_example_5.png" alt="fabric_network_example_5" /&gt;&lt;/p&gt;</description></item><item><title>Hyperledger Fabric 系统架构详解</title><link>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_structure/</guid><description>&lt;h1 id="hyperledger-fabric-系统架构详解"&gt;
 Hyperledger Fabric 系统架构详解
 &lt;a class="anchor" href="#hyperledger-fabric-%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84%e8%af%a6%e8%a7%a3"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;因为毕业 Case Study 的项目主要是基于&lt;code&gt;Ethereum&lt;/code&gt;公链，也没有面向企业的应用场景，所以之前对&lt;code&gt;Hyperledger Fabric&lt;/code&gt;的了解大多只是停留在它的权限管理机制、通道、灵活的智能合约编写等几个特色的概念，对它的架构、各个节点的角色、运行机制等都是一知半解。最近在上 HKU 的&lt;code&gt;&amp;lt;FITE3011 Distributed Ledger and Blockchain&amp;gt;&lt;/code&gt;课程，教授对&lt;code&gt;Hyperledger Fabric&lt;/code&gt;的工作原理、网络搭建及链码相关的知识做了很详细的讲解，受益匪浅，通过本文来梳理一下，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="hyperledger-概述"&gt;
 Hyperledger 概述
 &lt;a class="anchor" href="#hyperledger-%e6%a6%82%e8%bf%b0"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;要学习&lt;code&gt;Hyperledger Fabric&lt;/code&gt;，先来看看它的母项目&lt;code&gt;Hyperledger&lt;/code&gt;是什么。&lt;/p&gt;
&lt;p&gt;企业级应用有较复杂的业务逻辑和参与者角色划分，对于业务执行效率、安全性要求很高，并且针对常见的如支付、数据/信息交易等场景，隐私保护也是重中之重，因此，常见的比特币、以太坊等公链并不符合大部分企业应用需求。但是区块链的分布式、不可篡改的历史账本等特性在溯源、跨境电商等场景中又能够避免因各个国家/地区法律法规、货币等造成的复杂操作流程，大大提高效率。因此，针对企业的联盟链也在不断发展。&lt;/p&gt;
&lt;p&gt;联盟链严格意义上并不是真正的“去中心化”，它通过引入了权限管理机制（结合企业在现实业务中的角色）来弱化对节点作恶的预防机制，从而能提高效率、应对复杂的业务逻辑。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;Hyperledger&lt;/code&gt;是由 Linux 基金会维护的一组专注于跨行业分布式技术的开源项目，旨在创建企业级、开源、分布式的分类框架和代码库来支持业务用例，提供中立、开放和社区驱动的基础设施；建立技术社区并推广，开发区块链和共享账本概念验证、使用案例、试验和部署；建立行业标准，鼓励更多企业参与到分布式账本技术的建设和应用中来，形成一个开放的生态体系；教育公众关于区块链科技的市场机会。&lt;/p&gt;
&lt;h3 id="设计理念"&gt;
 设计理念
 &lt;a class="anchor" href="#%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/hyperledger_design_philosophy.png" alt="hyperledger_design_philosophy" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hyperledger&lt;/code&gt;有如下几个核心设计理念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它针对企业具体的业务场景提升效率，并且对溯源等场景有着独特优势，每个企业都可以针对自己的场景维护独立的&lt;code&gt;Hyperledger&lt;/code&gt;项目，因此，它不需要像公链一样通过数字货币来激励用户参与区块链系统。&lt;/li&gt;
&lt;li&gt;企业的应用场景较为复杂，往往 Hyperledger 只是在其中参与了某个或某些环节，因此与其他现有系统的交互必不可少，因此 Hyperledger 在设计上注重配备完整的 API 以供其他系统调用与交互。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hyperledger&lt;/code&gt;的框架结构是模块化、可拓展，企业可以根据具体的业务需求选择不同的模块，避免复杂的业务逻辑和臃肿的系统。&lt;/li&gt;
&lt;li&gt;企业应用的安全性是重中之重，尤其是许多应用场景牵扯到高价值交易或敏感数据，因此提供了很多机制来保障安全性（如&lt;code&gt;Fabric&lt;/code&gt;的通道机制等）&lt;/li&gt;
&lt;li&gt;除了与现有的系统交互外，企业未来的区块链应用中还可能会和很多不同的区块链网络进行交互，因此大部分智能合约/应用应该具备跨区块链网络的可移植性，以形成更复杂和强大的网络。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/hyperledger_family.png" alt="hyperledger_family" /&gt;&lt;/p&gt;
&lt;h4 id="框架"&gt;
 框架
 &lt;a class="anchor" href="#%e6%a1%86%e6%9e%b6"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Hyperledger&lt;/code&gt;下有如下几个项目，其中&lt;code&gt;Fabric&lt;/code&gt;目前应用最为广泛，本文也将主要介绍&lt;code&gt;Fabric&lt;/code&gt;区块链网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Burrow&lt;/li&gt;
&lt;li&gt;Fabric&lt;/li&gt;
&lt;li&gt;Grid&lt;/li&gt;
&lt;li&gt;Indy&lt;/li&gt;
&lt;li&gt;Iroha&lt;/li&gt;
&lt;li&gt;Sawtooth&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="工具"&gt;
 工具
 &lt;a class="anchor" href="#%e5%b7%a5%e5%85%b7"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Hyperledger Cello&lt;/code&gt;。主要用于更方便地搭建和管理区块链服务，降低项目框架部署、维护的复杂度；可以用来搭建区块链 BaaS 平台；可以通过 Dashboard 来创建和管理区块链，技术人员可以更方便地进行开发和部署；可以将 SaaS 部署模型引入区块链系统，帮助企业进一步开发框架。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hyperledger Explorer&lt;/code&gt;。是一个可视化区块链的操作工具，可以用于创建对用户友好的 Web 应用程序；是首个&lt;code&gt;Hyperledger&lt;/code&gt;的区块链浏览器，用户可以查看/调用/部署/查询交易、网络、智能合约、存储等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="hyperledger-fabric"&gt;
 Hyperledger Fabric
 &lt;a class="anchor" href="#hyperledger-fabric"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;我们着重来讲讲其中应用最广泛的&lt;code&gt;Fabric&lt;/code&gt;项目，它是由 Linux 基金会维护的一个模块化、可拓展的区块链联盟链项目，不依赖任何加密货币，它对有着共同目标（业务需求）但彼此不完全信息的实体之间的业务提供了保护，例如跨境电商、资金交易、溯源等。&lt;/p&gt;</description></item><item><title>IPFS 本地节点搭建（命令行）</title><link>https://guide.pseudoyu.com/zh/docs/ipfs/blockchain_ipfs_practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/ipfs/blockchain_ipfs_practice/</guid><description>&lt;h1 id="ipfs-本地节点搭建命令行"&gt;
 IPFS 本地节点搭建（命令行）
 &lt;a class="anchor" href="#ipfs-%e6%9c%ac%e5%9c%b0%e8%8a%82%e7%82%b9%e6%90%ad%e5%bb%ba%e5%91%bd%e4%bb%a4%e8%a1%8c"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;上一篇《&lt;a href="https://www.pseudoyu.com/zh/2021/03/25/blockchain_ipfs_structure/"&gt;IPFS 分布式文件存储原理&lt;/a&gt;》对于 IPFS 系统的设计理念、功能、工作原理及 IPNS 做了详细的介绍，那么，如何在本地搭建一个 IPFS 节点呢？&lt;/p&gt;
&lt;p&gt;本文在&lt;code&gt;macOS 11.2.3&lt;/code&gt;系统上搭建了一个 IPFS 节点（命令行版本），并对文件上传、下载、网络同步、&lt;code&gt;pin&lt;/code&gt;、&lt;code&gt;GC&lt;/code&gt;、&lt;code&gt;IPNS&lt;/code&gt;等进行了实际操作，以加深对 IPFS 工作原理的理解。&lt;/p&gt;
&lt;h2 id="代码实践"&gt;
 代码实践
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="安装"&gt;
 安装
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;wget https://dist.ipfs.io/go-ipfs/v0.8.0/go-ipfs_v0.8.0_darwin-amd64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tar -xvzf go-ipfs_v0.8.0_darwin-amd64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cd go-ipfs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;./install.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs --version&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="启动"&gt;
 启动
 &lt;a class="anchor" href="#%e5%90%af%e5%8a%a8"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 启动节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs init
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 上传文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs add ipfs_init_readme.png
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 上传文件并且只输出哈希值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs add -q ipfs_init_readme.png
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 上传目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs add -r &lt;span style="color:#f92672"&gt;[&lt;/span&gt;Dir&lt;span style="color:#f92672"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 查看文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/quick-start
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 查看自己上传的文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs cat QmaP3QS6ZfBoEaUJZ3ZfRKoBm3GGuhQSnUWtkVCNc8ZLTj
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 查看图片并输出到文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs cat QmfViXYw7GA296brLwid255ivDp1kmTiXJw1kmZVsg7DFH &amp;gt; ipfsTest.png
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 下载文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs get QmfViXYw7GA296brLwid255ivDp1kmTiXJw1kmZVsg7DFH -o ipfsTest.png
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 压缩并下载文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ipfs get QmfViXYw7GA296brLwid255ivDp1kmTiXJw1kmZVsg7DFH -Cao ipfsTest.png&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/ipfs_init_readme.png" alt="ipfs_init_readme" /&gt;&lt;/p&gt;</description></item><item><title>IPFS 分布式存储协议分析与思考</title><link>https://guide.pseudoyu.com/zh/docs/ipfs/blockchain_ipfs_structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/ipfs/blockchain_ipfs_structure/</guid><description>&lt;h1 id="ipfs-分布式存储协议分析与思考"&gt;
 IPFS 分布式存储协议分析与思考
 &lt;a class="anchor" href="#ipfs-%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e5%8d%8f%e8%ae%ae%e5%88%86%e6%9e%90%e4%b8%8e%e6%80%9d%e8%80%83"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;最近在做学校的 Case Study 项目，是一个基于&lt;code&gt;Ethereum&lt;/code&gt;平台的音乐版权管理项目，其中对于音乐作品、版权证明文件等上传用到了 IPFS 分布式文件存储技术，主要是利用其去重的特性来检测侵权行为。对 IPFS 这个系统产生了兴趣，阅读了&lt;a href="https://tech.hyperchain.cn"&gt;QTech 平台&lt;/a&gt;上的&lt;a href="https://tech.hyperchain.cn/tag/ipfs/"&gt;IPFS 系列文章&lt;/a&gt;，也查询了一些相关资料，通过本文梳理一下，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="概述"&gt;
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;我们日常使用网盘或其他服务时大多都是访问文件所在的特定的服务器（IP 地址），请求文件并下载到本地，通过的是 HTTP 协议，本质上是基于位置寻址的，访问 URL 来得到一层层找到具体的文件，这种方式固然便捷，但是存在一些问题。文件依托于特定的服务器，因此一旦中心化的服务器宕机或者文件被删除了，内容将永久丢失，并且如果离服务器很远/同时访问文件的人很多的话访问速度也会比较慢；而且同样一份文件可能重复存储在不同的服务器中，造成资源的浪费；此外就是存在严重的安全隐患，DDoS、XSS、CSRF 等攻击都可能对文件安全性造成威胁。&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;那有没有更好的解决方案呢？&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;试想我们把文件存储在一个分布式网络里，每个节点都可以存储文件，用户可以通过访问一个类似目录索引的方式来向最近的节点互相请求文件。这就是 IPFS 星际文件系统的解决思路，它是一个点对点的超媒体文件存储、索引、交换协议，由 Juan Benet 在 2014 年 5 月发起。&lt;/p&gt;
&lt;h3 id="特点"&gt;
 特点
 &lt;a class="anchor" href="#%e7%89%b9%e7%82%b9"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;IPFS 想把全世界所有部署了相同文件系统的计算设备链接在一起，构建一个分布式网络来替代传统中心化的服务器模式，每个节点都可以存储文件，用户通过&lt;code&gt;DHT(Distributed Hash Table)&lt;/code&gt;分布式哈希表来获取文件，速度更快、更安全，网络安全性更强。&lt;/p&gt;
&lt;p&gt;因为通过 IPFS 存储的文件内容是通过分块求 Hash 值存储为地址的，本质上是通过多重哈希来确定文件的地址，这是一种去中心化但是基于内容寻址的方式，通过对数据本身进行加密，生成独一无二的 Hash 以供查找，这种方式下，即使是微小的改变，也会造成 Hash 结果截然不同，因此很容易能够从 Hash 检测内容是否被篡改，甚至不用访问文件本身。&lt;/p&gt;
&lt;p&gt;不同于传统的服务器模式，IPFS 是一个统一的网络，因此已经上传的相同内容的文件不会重复存储（可以通过 Hash 值检验），极大地节约了整体网络资源，也更加高效。而且理论上只要节点达到一定规模，文件将永久保存，且同一个文件可以从多个（也更近）的节点下载，通讯效率也会更高。&lt;/p&gt;
&lt;p&gt;除此之外，因为是分布式网络进行存储，也可以天然地避免传统 DDoS 等攻击。&lt;/p&gt;
&lt;h3 id="功能"&gt;
 功能
 &lt;a class="anchor" href="#%e5%8a%9f%e8%83%bd"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;除了文件存储外，IPFS 还有 DHT 组网、Bitswap 文件交换等功能，之后也会单独写博文进行讲解。&lt;/p&gt;</description></item><item><title>Solidity 合约开发 - 玩转 ethers.js</title><link>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_ethersjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_ethersjs/</guid><description>&lt;h1 id="solidity-智能合约开发---玩转-ethersjs"&gt;
 Solidity 智能合约开发 - 玩转 ethers.js
 &lt;a class="anchor" href="#solidity-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%bc%80%e5%8f%91---%e7%8e%a9%e8%bd%ac-ethersjs"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在之前的《&lt;a href="https://www.pseudoyu.com/zh/2022/05/25/learn_solidity_from_scratch_basic/"&gt;Solidity 智能合约开发 - 基础&lt;/a&gt;》中，我们学习了 Solidity 的基本语法，并且了解了可以通过 &lt;a href="https://github.com/eth-brownie/brownie"&gt;Brownie&lt;/a&gt; 与 &lt;a href="https://github.com/NomicFoundation/hardhat"&gt;HardHat&lt;/a&gt; 等框架进行调试。而另一篇《&lt;a href="https://www.pseudoyu.com/zh/2022/05/30/learn_solidity_from_scratch_web3py/"&gt;Solidity 智能合约开发 - 玩转 Web3.py&lt;/a&gt;》中我们也通过 Web3.py 直接与我们本地的 Ganache 节点进行交互了。&lt;/p&gt;
&lt;p&gt;原本因为之前比较熟悉 Python 的使用，所以想使用 Brownie 框架进行后续开发。然而经过了一番调研，业界还是使用 HardHat 框架居多，也有更多拓展，且我关注的 Solidity 教程也更新了 &lt;a href="https://www.youtube.com/watch?v=gyMwXuJrbJQ"&gt;Javascript 版本&lt;/a&gt;，于是还是打算学习一下。&lt;/p&gt;
&lt;p&gt;为了更好了解其原理，也为我们后续更好使用框架打好基础，我们这次通过 &lt;a href="https://github.com/ethers-io/ethers.js/"&gt;ethers.js&lt;/a&gt; 来与我们部署在 &lt;a href="https://dashboard.alchemyapi.io"&gt;Alchemy&lt;/a&gt; 平台上的 Rinkeby 测试网络进行交互。实现了基础的合约编译、部署至 Rinkeby 网络、与合约交互等功能。&lt;/p&gt;
&lt;p&gt;可以点击&lt;a href="https://github.com/pseudoyu/learn-solidity/tree/master/ethers_simple_storage"&gt;这里&lt;/a&gt;访问本测试 Demo 代码仓库。&lt;/p&gt;
&lt;h2 id="ethersjs"&gt;
 ethers.js
 &lt;a class="anchor" href="#ethersjs"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;ethers.js 是 Javascript 的一个开源库，可以与以太坊网络进行交互，其 GitHub 地址为 &lt;a href="https://github.com/ethers-io/ethers.js/"&gt;ethers.io/ethers.js&lt;/a&gt;，可以访问其&lt;a href="https://docs.ethers.io/"&gt;官方文档&lt;/a&gt;进行使用。&lt;/p&gt;
&lt;h3 id="安装"&gt;
 安装
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;我们可以通过 yarn 安装 &lt;code&gt;ethers.js&lt;/code&gt;，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;yarn add ethers&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/yarn_add_ethers.png" alt="yarn_add_ethers" /&gt;&lt;/p&gt;
&lt;h3 id="使用"&gt;
 使用
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;require&lt;/code&gt; 导入库即可使用&lt;/p&gt;</description></item><item><title>Solidity 智能合约开发 - Hardhat 框架使用</title><link>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_hardhat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_hardhat/</guid><description>&lt;h1 id="solidity-智能合约开发---hardhat-框架使用"&gt;
 Solidity 智能合约开发 - Hardhat 框架使用
 &lt;a class="anchor" href="#solidity-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%bc%80%e5%8f%91---hardhat-%e6%a1%86%e6%9e%b6%e4%bd%bf%e7%94%a8"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;经过了前几篇对智能合约基础、Web3.py、ethers.js 的学习，我们已经掌握了通过程序与区块链网络直接交互的基础知识，不熟悉的同学可以回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.pseudoyu.com/zh/2022/05/25/learn_solidity_from_scratch_basic/"&gt;Solidity 智能合约开发 - 基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.pseudoyu.com/zh/2022/05/30/learn_solidity_from_scratch_web3py/"&gt;Solidity 智能合约开发 - 玩转 Web3.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.pseudoyu.com/zh/2022/06/08/learn_solidity_from_scratch_ethersjs/"&gt;Solidity 智能合约开发 - 玩转 ethers.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是在真正的复杂业务场景中，我们往往会使用一些进一步封装的框架，如 HardHat、Brownie、Truffle 等，HardHat 是其中应用最广泛、插件拓展最为强大的。本系列将从这篇开始专注于 Hardhat 框架的使用与最佳实践，而本篇则会通过一个简单的例子完成其安装、配置与使用。&lt;/p&gt;
&lt;p&gt;本文是对 &lt;a href="https://twitter.com/PatrickAlphaC"&gt;Patrick Collins&lt;/a&gt; 的 『&lt;a href="https://www.youtube.com/watch?v=gyMwXuJrbJQ"&gt;Learn Blockchain, Solidity, and Full Stack Web3 Development with JavaScript&lt;/a&gt;』 教程的学习整理，强烈建议看原教程视频了解更多细节。&lt;/p&gt;
&lt;p&gt;可以点击&lt;a href="https://github.com/pseudoyu/learn-solidity/tree/master/hardhat_simple_storage"&gt;这里&lt;/a&gt;访问本测试 Demo 代码仓库。&lt;/p&gt;
&lt;h2 id="hardhat-介绍"&gt;
 Hardhat 介绍
 &lt;a class="anchor" href="#hardhat-%e4%bb%8b%e7%bb%8d"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/hardhat_homepage.png" alt="hardhat_homepage" /&gt;&lt;/p&gt;
&lt;p&gt;Hardhat 是一个基于 JavaScript 的智能合约开发环境，可以用于灵活地编译、部署、测试和调试基于 EVM 的智能合约，并且提供了一系列工具链来整合代码与外部工具，还提供了丰富的插件生态，提升开发效率。此外，它还提供了模拟以太坊的本地 Hardhat 网络节点，提供强大的本地调试功能。&lt;/p&gt;
&lt;p&gt;其 GitHub 地址为 &lt;a href="https://github.com/NomicFoundation/hardhat"&gt;NomicFoundation/hardhat&lt;/a&gt;，可以访问其&lt;a href="https://hardhat.org/getting-started"&gt;官方文档&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;h2 id="hardhat-使用"&gt;
 Hardhat 使用
 &lt;a class="anchor" href="#hardhat-%e4%bd%bf%e7%94%a8"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="初始化项目"&gt;
 初始化项目
 &lt;a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%b9%e7%9b%ae"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;从零开始搭建一个 Hardhat 项目，我们需要预先安装好 &lt;code&gt;node.js&lt;/code&gt; 与 &lt;code&gt;yarn&lt;/code&gt; 环境，这部份参照官方说明根据自己的系统环境按照即可。&lt;/p&gt;</description></item><item><title>Solidity 智能合约开发 - 基础</title><link>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_basic/</guid><description>&lt;h1 id="solidity-智能合约开发---基础"&gt;
 Solidity 智能合约开发 - 基础
 &lt;a class="anchor" href="#solidity-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%bc%80%e5%8f%91---%e5%9f%ba%e7%a1%80"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;去年读研的时候上的 HKU 的 &lt;code&gt;&amp;lt;COMP7408 Distributed Ledger and Blockchain Technology&amp;gt;&lt;/code&gt;，课程中学习了以太坊智能合约的开发，做了一个简单的图书管理 ÐApp，然后毕业设计也选择了基于 Ethereum 做了一个音乐版权应用，详见 &lt;a href="https://github.com/pseudoyu/uright"&gt;Uright - 区块链音乐版权管理ÐApp&lt;/a&gt;，对 Solidity 开发有一些基础了解。&lt;/p&gt;
&lt;p&gt;后来工作后主要做联盟链和业务开发这一块，很久没有碰过合约，对于语法和底层一些概念都已经一知半解，正好最近做的项目是基于 EVM 的一条链，涉及了一些基本的存证、回检和迁移相关合约的开发，调试起来有些吃力，于是打算系统学习一下，梳理一下笔记成文章，敦促自己好好思考总结。&lt;/p&gt;
&lt;p&gt;这系列文章也会收录在我的个人知识库项目 《&lt;a href="https://www.pseudoyu.com/blockchain-guide/"&gt;区块链入门指南&lt;/a&gt;》中，希望在学习过程中不断完善。有兴趣的朋友也可以访问&lt;a href="https://github.com/pseudoyu/blockchain-guide"&gt;项目仓库&lt;/a&gt;参与贡献或提出建议。&lt;/p&gt;
&lt;p&gt;本文为系列第一篇，主要涉及 Solidity 基础知识。&lt;/p&gt;
&lt;h2 id="智能合约-与-solidity-语言"&gt;
 智能合约 与 Solidity 语言
 &lt;a class="anchor" href="#%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6-%e4%b8%8e-solidity-%e8%af%ad%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;智能合约是运行在链上的程序，合约开发者可以通过智能合约实现与链上资产/数据进行交互，用户可以通过自己的链上账户来调用合约，访问资产与数据。因为区块链保留区块历史记录的链式结构、去中心化、不可篡改等特征，智能合约相比传统应用来说能更公正、透明。&lt;/p&gt;
&lt;p&gt;然而，因为智能合约需要与链进行交互，部署、数据写入等操作都会消耗一定费用，数据存储与变更成本也比较高，因此在设计合约时需要着重考虑资源的消耗。此外，常规智能合约一经部署就无法进行修改，因此，合约设计时也需要多考虑其安全性、可升级性与拓展性。&lt;/p&gt;
&lt;p&gt;Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言，在 EVM 虚拟机上运行，语法整体类似于 Javascript，是目前最流行的智能合约语言，也是入门区块链与 Web3 所必须掌握的语言。针对上述的一些合约编写的问题，Solidity 也都有相对完善的解决方案支持，后续会详细讲解。&lt;/p&gt;
&lt;h2 id="开发调试工具"&gt;
 开发/调试工具
 &lt;a class="anchor" href="#%e5%bc%80%e5%8f%91%e8%b0%83%e8%af%95%e5%b7%a5%e5%85%b7"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;与常规编程语言不同，Solidity 智能合约的开发往往无法直接通过一个 IDE 或本地环境进行方便的调试，而是需要与一个链上节点进行交互。开发调试往往也不会直接与主网（即真实资产、数据与业务所在的链）进行交互，否则需要承担高额手续费。目前开发调试主要有以下几种方式与框架：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://remix.ethereum.org"&gt;Remix IDE&lt;/a&gt;。通过 Ethereum 官方提供的基于浏览器的 Remix 开发工具进行调试，Remix 会提供完整的 IDE、编译工具、部署调试的测试节点环境、账户等，可以很方便地进行测试，这是我学习使用时用的最多的工具。Remix 还可以通过 MetaMask 插件与测试网、主网进行直接交互，部分生产环境也会使用它进行编译部署。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/trufflesuite/truffle"&gt;Truffle&lt;/a&gt;。Truffle 是一个非常流行的 Javascript 的 Solidity 合约开发框架，提供了完整的开发、测试、调试工具链，可以与本地或远程网络进行交互。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eth-brownie/brownie"&gt;Brownie&lt;/a&gt;。Brownie 是一个基于 Python 的 Solidity 合约开发框架，以简洁的 Python 语法为调试和测试提供了便捷的工具链。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/NomicFoundation/hardhat"&gt;Hardhat&lt;/a&gt;。Hardhat 是另一个基于 Javascript 的开发框架，提供了非常丰富的插件系统，适合开发复杂的合约项目。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了开发框架外，更好地进行 Solidity 还需要熟悉一些工具：&lt;/p&gt;</description></item><item><title>Solidity 智能合约开发 - 玩转 Web3.py</title><link>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_web3py/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/solidity/learn_solidity_from_scratch_web3py/</guid><description>&lt;h1 id="solidity-智能合约开发---玩转-web3py"&gt;
 Solidity 智能合约开发 - 玩转 Web3.py
 &lt;a class="anchor" href="#solidity-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%bc%80%e5%8f%91---%e7%8e%a9%e8%bd%ac-web3py"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在前文《&lt;a href="https://www.pseudoyu.com/zh/2022/05/25/learn_solidity_from_scratch_basic/"&gt;Solidity 智能合约开发 - 基础&lt;/a&gt;》中，我们学习了 Solidity 的基本语法，并且了解了可以通过 &lt;a href="https://github.com/eth-brownie/brownie"&gt;Brownie&lt;/a&gt; 与 &lt;a href="https://github.com/NomicFoundation/hardhat"&gt;HardHat&lt;/a&gt; 等框架进行调试。但在使用这些封装好的框架之前，我们可以通过 Web3.py 直接与我们本地的 Ganache 节点进行交互，以便更好了解其原理，也为我们后续更好使用框架打好基础。&lt;/p&gt;
&lt;p&gt;本文以 Web3.py 为例，实现了基础的合约编译、部署至本地 Ganache 网络、与合约交互等功能。&lt;/p&gt;
&lt;p&gt;可以点击&lt;a href="https://github.com/pseudoyu/learn-solidity/tree/master/web3_py_simple_storage"&gt;这里&lt;/a&gt;访问本测试 Demo 代码仓库。&lt;/p&gt;
&lt;h2 id="web3py"&gt;
 Web3.py
 &lt;a class="anchor" href="#web3py"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Web3.py 是 Python 的一个开源库，它提供了一个简单的 API，可以让我们通过 Python 程序与以太坊网络进行交互。其 GitHub 地址为 &lt;a href="https://github.com/ethereum/web3.py"&gt;ethereum/web3.py&lt;/a&gt;，可以访问其&lt;a href="https://web3py.readthedocs.io/en/stable/"&gt;官方文档&lt;/a&gt;进行使用。&lt;/p&gt;
&lt;h3 id="安装"&gt;
 安装
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;我们可以通过 Python 包管理工具 pip 安装 Web3.py，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;pip3 install web3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/pip_install_web3.png" alt="pip_install_web3" /&gt;&lt;/p&gt;
&lt;h3 id="使用"&gt;
 使用
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;import&lt;/code&gt; 导入所需方法即可使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; web3 &lt;span style="color:#f92672"&gt;import&lt;/span&gt; Web3
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;w3 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; Web3(Web3&lt;span style="color:#f92672"&gt;.&lt;/span&gt;HTTPProvider(&lt;span style="color:#e6db74"&gt;&amp;#34;HTTP://127.0.0.1:7545&amp;#34;&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="solidity-合约编译"&gt;
 Solidity 合约编译
 &lt;a class="anchor" href="#solidity-%e5%90%88%e7%ba%a6%e7%bc%96%e8%af%91"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="合约源码"&gt;
 合约源码
 &lt;a class="anchor" href="#%e5%90%88%e7%ba%a6%e6%ba%90%e7%a0%81"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-solidity" data-lang="solidity"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// SPDX-License-Identifier: MIT
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;pragma solidity&lt;/span&gt; &lt;span style="color:#f92672"&gt;^&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;.&lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;.&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;contract&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;SimpleStorage&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt; favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; favoriteBool;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;People&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt; favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; People &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; person &lt;span style="color:#f92672"&gt;=&lt;/span&gt; People({favoriteNumber&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;, name&lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;Arthur&amp;#34;&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; People[] &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; people;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;mapping&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; &lt;span style="color:#f92672"&gt;=&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; nameToFavoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;store&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt; _favoriteNumber) &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;returns&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; favoriteNumber &lt;span style="color:#f92672"&gt;=&lt;/span&gt; _favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;retrieve&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;view&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;returns&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;function&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;addPerson&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;memory&lt;/span&gt; _name, &lt;span style="color:#66d9ef"&gt;uint256&lt;/span&gt; _favoriteNumber) &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; people.push(People({favoriteNumber&lt;span style="color:#f92672"&gt;:&lt;/span&gt; _favoriteNumber, name&lt;span style="color:#f92672"&gt;:&lt;/span&gt; _name}));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; nameToFavoriteNumber[_name] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; _favoriteNumber;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一个简单的存储合约，通过一个 People 结构体对象来存储人名和他喜欢数字，通过一个数组来存储多个人的信息，并提供了添加、查找方法。&lt;/p&gt;</description></item><item><title>Solidity 智能合约开发 - 玩转 Web3.py</title><link>https://guide.pseudoyu.com/zh/docs/solidity/two_phase_commit_contract_practice_in_solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/solidity/two_phase_commit_contract_practice_in_solidity/</guid><description>&lt;h1 id="通过状态锁在-solidity-智能合约中实现两阶段提交"&gt;
 通过状态锁在 Solidity 智能合约中实现两阶段提交
 &lt;a class="anchor" href="#%e9%80%9a%e8%bf%87%e7%8a%b6%e6%80%81%e9%94%81%e5%9c%a8-solidity-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e4%b8%ad%e5%ae%9e%e7%8e%b0%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在一些牵扯到多个系统或合约交互的智能合约应用场景中，尤其是一些资产/数据准确性较为敏感的业务中，我们需要保证在整个业务流程中数据的原子性。因此，我们需要在合约层面实现类似多阶段提交的机制，即将合约中的状态更改过程分解为预提交和正式提交两个阶段。&lt;/p&gt;
&lt;p&gt;本文通过状态锁的机制实现了一个最小化的两阶段提交模型，完整合约代码参见 &lt;a href="https://github.com/pseudoyu/learn-solidity/blob/master/practice/two_phase_commit/TwoPhaseCommit.sol"&gt;TwoPhaseCommit.sol&lt;/a&gt;，下文将对本合约核心逻辑进行讲解，并尽量遵循风格指南与最佳实践。&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;注：本合约因初始场景主要考虑的是联盟链中的业务用途，未对 Gas fee 等进行特定优化，仅供学习参考。&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id="合约逻辑"&gt;
 合约逻辑
 &lt;a class="anchor" href="#%e5%90%88%e7%ba%a6%e9%80%bb%e8%be%91"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="合约结构"&gt;
 合约结构
 &lt;a class="anchor" href="#%e5%90%88%e7%ba%a6%e7%bb%93%e6%9e%84"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;两阶段提交场景包含以下方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set: 两阶段 - 预提交&lt;/li&gt;
&lt;li&gt;commit: 两阶段 - 正式提交&lt;/li&gt;
&lt;li&gt;rollback: 两阶段 - 回滚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因 Solidity 语言对于字符串长度判断/比较等有一些限制，为了提升合约代码的可读性，本合约提供了部分辅助方法，主要包含以下方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;isValidKey: 检查 key 是否合法&lt;/li&gt;
&lt;li&gt;isValidValue: 检查 value 是否合法&lt;/li&gt;
&lt;li&gt;isEqualString: 比较两个字符串是否相等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="两阶段提交核心逻辑"&gt;
 两阶段提交核心逻辑
 &lt;a class="anchor" href="#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4%e6%a0%b8%e5%bf%83%e9%80%bb%e8%be%91"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;在两阶段提交场景中，本合约提供了一套简易的 &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt; 方法实现，实现了将合约调用传入的 key-value 键值对存储到链上。我们通过状态锁的机制来实现跨链交易的原子性。我们定义了如下数据结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-solidity" data-lang="solidity"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;enum&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;State&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; UNLOCKED,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; LOCKED
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Payload&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; State state;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; lockValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，&lt;code&gt;State&lt;/code&gt; 为枚举类型，记录了链上 key 值的锁定状态，而 &lt;code&gt;Payload&lt;/code&gt; 结构则会对锁定状态、当前值与正在锁定的值进行存储，并通过如下 &lt;code&gt;mapping&lt;/code&gt; 结构与 key 进行绑定：&lt;/p&gt;</description></item><item><title>比特币核心技术解读</title><link>https://guide.pseudoyu.com/zh/docs/bitcoin/blockchain_bitcoin_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/bitcoin/blockchain_bitcoin_basic/</guid><description>&lt;h1 id="比特币核心技术解读"&gt;
 比特币核心技术解读
 &lt;a class="anchor" href="#%e6%af%94%e7%89%b9%e5%b8%81%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e8%a7%a3%e8%af%bb"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在上一篇文章《&lt;a href="https://www.pseudoyu.com/zh/2021/02/12/blockchain_basic/"&gt;区块链基础知识与关键技术&lt;/a&gt;》里对区块链的基础知识和关键技术进行了梳理，而比特币是区块链最典型的应用，本文将对比特币核心技术进行解读，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="比特币系统"&gt;
 比特币系统
 &lt;a class="anchor" href="#%e6%af%94%e7%89%b9%e5%b8%81%e7%b3%bb%e7%bb%9f"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;比特币是在 2009 年由中本聪发明的一个数字货币，主要是为了反抗中心化的银行体系，因为其精巧的系统设计和安全性，价值也在迅速提升。同时，因为它并不与真实世界的身份绑定，具备强大的匿名性，也被用于非法交易、洗钱、勒索等恶意行为，引起了一些争议。&lt;/p&gt;
&lt;p&gt;作为一个去中心化的区块链系统，所有人都可以访问，也可以在本地维护一个节点参与到比特币网络中，下文也会应用&lt;code&gt;Bitcoin Core&lt;/code&gt;客户端在本地维护一个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/bitcoin_network_nodes.png" alt="bitcoin_network_nodes" /&gt;&lt;/p&gt;
&lt;p&gt;节点分为全节点和轻节点两种，早期所有的节点都是全节点，但随着数据量越来越大，运行在手机或平板等设备上的比特币客户端不需要存储整个区块链的信息，称为&lt;code&gt;Simplified Payment Verification(SPV)&lt;/code&gt;节点，也叫轻节点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bitcoin Core&lt;/code&gt;客户端就是一个全节点，下文也会具体讲述。全节点一直在线，维护着完整的区块链信息；因为其内存里维护着完整的&lt;code&gt;UTXO&lt;/code&gt;集合，所以通过验证整个区块链的区块和交易信息（从创世区块到最新区块）来验证交易的合法性；也会决定哪些交易会被打包到区块中；验证交易即挖矿，可以决定沿着哪条链继续挖，在出现等长的分叉时，也会选择哪一个分叉；同时监听别的矿工挖出来的区块，验证合法性。&lt;/p&gt;
&lt;p&gt;轻节点不需要一直在线，也不需要保留整个区块链（数据量庞大），只需要保留每个区块的块头；且只需要保存与自己有关的区块，而不需要保存链上全部交易；因为并没有保存全部信息，无法验证大多数交易的合法性和网上发布的新区块的正确性，只能检验与自己有关的区块；可以通过&lt;code&gt;Merkle Proof&lt;/code&gt;验证一笔交易存在，但不能确认一笔交易不存在；可以验证挖矿的难度，因为保存在块头中。&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;下面通过一个示例来讲解一下全节点和轻节点的交易验证方式。&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;假如要验证一个位于 block 300,000 的交易 T，全节点会查验全部 300,000 个区块（直到创世区块），建立一个完整&lt;code&gt;UTXO&lt;/code&gt;的数据库来确保这个交易没有被花费；而轻节点则会通过&lt;code&gt;Merkle Path&lt;/code&gt;来链接所有和交易 T 相关的区块，然后等待 300,001 至 300,006 个区块来进行确认，从而验证交易的合法性。&lt;/p&gt;
&lt;h3 id="区块链结构"&gt;
 区块链结构
 &lt;a class="anchor" href="#%e5%8c%ba%e5%9d%97%e9%93%be%e7%bb%93%e6%9e%84"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;区块链是由顺序链接起来的区块组成的一种数据结构，可以存于单文件或者数据库中，&lt;code&gt;Bitcoin Client&lt;/code&gt;使用 Google 的&lt;code&gt;LevelDB&lt;/code&gt;数据库存储数据。每一个区块都指向前一个区块，任何一个区块进行了修改的话，其所有后面的区块都会受到影响，所以想要篡改一个区块的话需要同时篡改之后的所有区块，这需要大量的算力，往往成本大于收益，因此极大地保障了安全性。&lt;/p&gt;
&lt;p&gt;区块链结构包含区块&lt;code&gt;Block Size (4 bytes)&lt;/code&gt;、&lt;code&gt;Block Header&lt;/code&gt;、&lt;code&gt;Transaction Counter(1-9 bytes)&lt;/code&gt;和&lt;code&gt;Transaction&lt;/code&gt;几个核心组成部分。&lt;/p&gt;
&lt;p&gt;区块链的块头大小为 80 bytes，存储着&lt;code&gt;Version(4 bytes)&lt;/code&gt;、&lt;code&gt;Previous Block Hash(32 bytes)&lt;/code&gt;、&lt;code&gt;Merkle Tree Root(32 bytes)&lt;/code&gt;、&lt;code&gt;Timestamp(4 bytes)&lt;/code&gt;、&lt;code&gt;Difficulty Target(4 bytes)&lt;/code&gt;和&lt;code&gt;Nonce(4 bytes)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每一个区块的哈希值通过对区块头进行两次哈希运算，即&lt;code&gt;SHA256(SHA256(Block Header))&lt;/code&gt;，并不存在区块链结构中，而是由每个节点接收到区块后计算得到，是独一无二的；此外，&lt;code&gt;Block Height&lt;/code&gt;也可以作为区块的标识符。&lt;/p&gt;</description></item><item><title>跨链技术原理与实战</title><link>https://guide.pseudoyu.com/zh/docs/crosschain/blockchain_crosschain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/crosschain/blockchain_crosschain/</guid><description>&lt;h1 id="跨链技术原理与实战"&gt;
 跨链技术原理与实战
 &lt;a class="anchor" href="#%e8%b7%a8%e9%93%be%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%98"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;目前区块链底层平台日渐多样，如老牌的 Hyperledger Fabric、Ethereum 等，以及国内的 Hyperchain、Z-ledger 等，而随着区块链应用生态越来越复杂，单链的性能有一定瓶颈，链与链之间的协同与交互（信息同步、共享、合约互操作等）也成为了链和应用生态发展的重要部分。&lt;/p&gt;
&lt;p&gt;本文是对跨链技术的概念与主流解决方案的梳理。&lt;/p&gt;
&lt;h2 id="跨链技术概览"&gt;
 跨链技术概览
 &lt;a class="anchor" href="#%e8%b7%a8%e9%93%be%e6%8a%80%e6%9c%af%e6%a6%82%e8%a7%88"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;因为底层链设计、共识算法、网络结构等组件的相似性，同构区块链之间的交互比较容易，但异构区块链则相对复杂，往往难以直接进行交互，而需要两条链之间有一些辅助平台/服务来进行数据格式转换等。&lt;/p&gt;
&lt;h3 id="跨链机制"&gt;
 跨链机制
 &lt;a class="anchor" href="#%e8%b7%a8%e9%93%be%e6%9c%ba%e5%88%b6"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;目前跨链主要由以下几种解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公证人机制&lt;/li&gt;
&lt;li&gt;哈希锁定&lt;/li&gt;
&lt;li&gt;分布式私钥控制&lt;/li&gt;
&lt;li&gt;侧链/中继链&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="公证人机制"&gt;
 公证人机制
 &lt;a class="anchor" href="#%e5%85%ac%e8%af%81%e4%ba%ba%e6%9c%ba%e5%88%b6"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;公证人机制是一种通过第三方中介协助不同链之间交互的机制，本质上是两方共同信任一个第三方，让其对跨链数据或跨链交互操作进行验证和转发。这种方式能很好地支持异构区块链，但是是一种中心化方式。&lt;/p&gt;
&lt;p&gt;很多数字货币交易所就是通过这样的方式进行不同数字货币之间的交易和转换，本质上是交易所在撮合交易，效率等都较高，但是存在一定安全风险，且只支持资产的交换。&lt;/p&gt;
&lt;h4 id="哈希锁定"&gt;
 哈希锁定
 &lt;a class="anchor" href="#%e5%93%88%e5%b8%8c%e9%94%81%e5%ae%9a"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;哈希锁定最早出现在比特币的闪电网络，是通过哈希锁和时间锁保障跨链双方资产的一种方式。其中时间锁是将交易限制在一定时间内，超时则交易失效，从而避免损失，但这种方式同样只能实现资产的交换，而无法实现资产的转移。&lt;/p&gt;
&lt;h4 id="侧链"&gt;
 侧链
 &lt;a class="anchor" href="#%e4%be%a7%e9%93%be"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;侧链是一种双向锚定的技术，最开始的侧链是相对于比特币主链而言的，如 BTC-Relay，在这条侧链上可以对比特币进行新特性的研发和测试，且当大量用户在比特币网络上进行交易时，使用侧链可以有效地拓展网络的吞吐量。例如，在 Ethereum 主链上进行资产交易和价值转移，而在 Ethereum 侧链上可以进行一些对 tps 要求较高的 DApp 运行等。&lt;/p&gt;
&lt;p&gt;而同一条主链的不同侧链也可以借助主链来进行一些交互，这就是借助测链进行跨链的基本原理。&lt;/p&gt;
&lt;h4 id="中继链"&gt;
 中继链
 &lt;a class="anchor" href="#%e4%b8%ad%e7%bb%a7%e9%93%be"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;中继链则是上述侧链和公证人机制的一种综合应用，通过设定跨链交互机制（如 Cosmos 的 IBC）来实现异构链之间的信息共享与交互。需要进行跨链的各个平行链连接到一个中继链来辅助交易的验证和交互。&lt;/p&gt;
&lt;h2 id="跨链技术实践"&gt;
 跨链技术实践
 &lt;a class="anchor" href="#%e8%b7%a8%e9%93%be%e6%8a%80%e6%9c%af%e5%ae%9e%e8%b7%b5"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="开发实战"&gt;
 开发实战
 &lt;a class="anchor" href="#%e5%bc%80%e5%8f%91%e5%ae%9e%e6%88%98"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;目前在做一个 BaaS 平台的跨链功能，其基础架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/cross_chain_framework.png" alt="cross_chain_framework" /&gt;&lt;/p&gt;
&lt;p&gt;子链主要是实现各类业务和应用的链，当子链要与其他链进行跨链业务交互时，它需要执行跨链合约，而我们提供了一个跨链网关来对这些跨链合约进行监听。针对异构区块链。如 Hyperledger Fabric、Ethereum，我们将提供不同的适配器来实现跨链 SDK 与跨链网关之间的交互，适配器提供跨链合约信息查询功能。当另一条业务链的 SDK 接收到跨链合约方法时，如果是合约互调用或数据传递，则直接调用对应的合约方法。&lt;/p&gt;</description></item><item><title>区块链服务平台 (BaaS) 简介及架构</title><link>https://guide.pseudoyu.com/zh/docs/baas/blockchain_baas_platform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/baas/blockchain_baas_platform/</guid><description>&lt;h1 id="区块链服务平台-baas-简介及架构"&gt;
 区块链服务平台 (BaaS) 简介及架构
 &lt;a class="anchor" href="#%e5%8c%ba%e5%9d%97%e9%93%be%e6%9c%8d%e5%8a%a1%e5%b9%b3%e5%8f%b0-baas-%e7%ae%80%e4%bb%8b%e5%8f%8a%e6%9e%b6%e6%9e%84"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;目前工作中负责一个针对 Hyperledger Fabric 的区块链即服务 (Blockchain as a Service, BaaS) 平台的链码管理部分，对这 BaaS 平台的架构与实现很感兴趣，作为一个能为开发者提供一站式应用创建、管理和维护区块链的平台，其架构是怎么样的呢？&lt;/p&gt;
&lt;p&gt;本文是对 BaaS 平台架构的总结和梳理。&lt;/p&gt;
&lt;h2 id="baas-简介"&gt;
 BaaS 简介
 &lt;a class="anchor" href="#baas-%e7%ae%80%e4%bb%8b"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;区块链是一个复杂的分布式系统，尤其是像 Hyperledger Fabric 这样的企业联盟链平台，其部署和运维都非常复杂，作为应用开发者需要处理许多环境问题（如证书、docker 环境等），带来了许多挑战。&lt;/p&gt;
&lt;p&gt;因此，BaaS 平台应运而生，它是一种帮助用户创建、管理和维护企业级区块链的应用平台，用户能够通过友好的 Web 界面对区块链进行操作。通过 BaaS 平台，用户可以很灵活地搭建区块链网络、管理区块链业务和各个模块的功能、进行智能合约的研发和部署以及实时监控和运维。&lt;/p&gt;
&lt;p&gt;通过 BaaS 平台，开发者可以快速进行区块链业务的研发，综合成本大大降低，且有助于系统稳定性、安全性和易用性等的提升。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/baas_framework.png" alt="baas_framework" /&gt;&lt;/p&gt;
&lt;h2 id="平台架构"&gt;
 平台架构
 &lt;a class="anchor" href="#%e5%b9%b3%e5%8f%b0%e6%9e%b6%e6%9e%84"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;BaaS 平台作为一个一站式应用服务，自下而上主要分为以下几层：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源层&lt;/li&gt;
&lt;li&gt;监控运维层&lt;/li&gt;
&lt;li&gt;区块链底层&lt;/li&gt;
&lt;li&gt;区块链服务层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而根据每个系统的业务差异，各个层的架构与功能模块会有所差异，下面将会对几大主流平台层次结构做一些描述。&lt;/p&gt;
&lt;h3 id="hyperledger-cello"&gt;
 Hyperledger Cello
 &lt;a class="anchor" href="#hyperledger-cello"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://image.pseudoyu.com/images/hyperledger_cello_overview.png" alt="hyperledger_cello_overview" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hyperledger/cello"&gt;Hyperledger Cello&lt;/a&gt; 作为 IBM Hyperledger 的顶级项目之一，是一个开源区块链管理平台，支持部署、运行时管理和数据分析等功能。&lt;/p&gt;
&lt;p&gt;Cello 目前支持 Hyperledger Fabric 区块链，可以有效管理 Fabric 链的生命周期，主要包含以下模块：&lt;/p&gt;</description></item><item><title>区块链基础知识与关键技术</title><link>https://guide.pseudoyu.com/zh/docs/blockchain/blockchain_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/blockchain/blockchain_basic/</guid><description>&lt;h1 id="区块链基础知识与关键技术"&gt;
 区块链基础知识与关键技术
 &lt;a class="anchor" href="#%e5%8c%ba%e5%9d%97%e9%93%be%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e4%b8%8e%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="前言"&gt;
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;最近对在上 HKU 的&lt;code&gt;&amp;lt;COMP7408 Distributed Ledger and Blockchain Technology&amp;gt;&lt;/code&gt;课程，对区块链的基础概念有了更系统的认知，结合之前上过的北京大学肖臻老师《&lt;a href="https://www.bilibili.com/video/BV1Vt411X7JF"&gt;区块链技术与应用&lt;/a&gt;》公开课，深知区块链知识体系之庞大，打算更新系列文章对区块链、比特币、以太坊等进行系统的知识梳理，如有错漏，欢迎交流指正。&lt;/p&gt;
&lt;h2 id="区块链中的密码学原理"&gt;
 区块链中的密码学原理
 &lt;a class="anchor" href="#%e5%8c%ba%e5%9d%97%e9%93%be%e4%b8%ad%e7%9a%84%e5%af%86%e7%a0%81%e5%ad%a6%e5%8e%9f%e7%90%86"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;区块链和密码学紧密相关，如比特币采用的核心的公私钥加密技术、数字签名、哈希等，包括很多共识算法也是基于复杂的密码学概念，因此，在开始学习区块链之前，要先了解几个核心的密码学概念，从而能够更深入理解其在区块链体系中的应用。&lt;/p&gt;
&lt;h3 id="哈希函数"&gt;
 哈希函数
 &lt;a class="anchor" href="#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;哈希函数是把一个任意长度的源数据经过一系列算法变成一个固定长度输出值的方法，概念很简单，但其具备的几个特性使它被各个领域广泛应用。&lt;/p&gt;
&lt;p&gt;可以访问这个 &lt;a href="https://andersbrownworth.com/blockchain/hash"&gt;Demo&lt;/a&gt; 体验一下哈希函数的工作原理（以&lt;code&gt;SHA256&lt;/code&gt;为例）！&lt;/p&gt;
&lt;p&gt;第一个特性是单向不可逆性。将一个输入 x 进行哈希运算得到值 H(x)，这一过程很容易，但是如果给定一个值 H(x)，几乎不可能逆推得到 x 的取值，这一特性很好地保护了源数据。&lt;/p&gt;
&lt;p&gt;第二个特性是抗碰撞性。给定一个值 x 和另一个值 y，如果 x 不等于 y，那 H(x) 几乎不可能等于 H(y)，并非完全不可能，但是几率非常低，因此，一个数据的 Hash 值几乎是唯一的，这可以很好地用于身份验证等场景。&lt;/p&gt;
&lt;p&gt;第三个特性是哈希计算不可预测。很难根据现有条件推导出哈希值，但是很容易检验是否正确，这一机制主要应用于&lt;code&gt;PoW&lt;/code&gt;挖矿机制中。&lt;/p&gt;
&lt;h3 id="加密解密"&gt;
 加密/解密
 &lt;a class="anchor" href="#%e5%8a%a0%e5%af%86%e8%a7%a3%e5%af%86"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;加密机制主要分为对称加密和非对称加密两类。&lt;/p&gt;
&lt;p&gt;对称加密机制是两方用同一个密钥来进行信息的加密和解密，很方便，效率也很高，但是密钥的分发存在很大的风险，如果通过网络等方式进行分发，很容易会出现密钥泄漏，从而导致信息泄漏。&lt;/p&gt;
&lt;p&gt;非对称加密机制主要指的是公私钥加密机制，每个人通过算法生成一对密钥，称为公钥和私钥，如果 A 想发送一个信息给 B，可以用 B 的公钥对文件进行加密，将加密后的信息发给 B，这个过程中，即使信息被截获或出现泄漏，也不会暴露源文件，所以可以用任何方式进行传播，当 B 收到加密文件后，用自己的私钥进行解密，从而获取文件内容。B 的私钥没有经过任何渠道进行传播，仅自己知道，所以具备极高的安全性。&lt;/p&gt;
&lt;p&gt;在现实应用中，对很大的文件进行非对称加密效率较低，所以一般采用一种组合机制：假设 A 想发送一个大文件 D 给 B，则先将文件 D 用一个密钥 K 进行对称加密，再用 B 的公钥对密钥 K 进行非对称加密。A 将加密后的密钥 K 和文件 D 发送给 B，期间即使被截获或泄漏，因为没有 B 的私钥，所以无法得到密钥 K，也就无法访问文件 D。B 收到加密后的文件和密钥后，则先用自己的私钥解密得到密钥 K，再用密钥 K 对文件 D 进行解密，从而获取文件内容。&lt;/p&gt;</description></item><item><title>学习路径</title><link>https://guide.pseudoyu.com/zh/docs/study_path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://guide.pseudoyu.com/zh/docs/study_path/</guid><description>&lt;h1 id="学习路径"&gt;
 学习路径
 &lt;a class="anchor" href="#%e5%ad%a6%e4%b9%a0%e8%b7%af%e5%be%84"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;区块链涉及很多方面的知识，这是我所推荐的学习路径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区块链基础&lt;/li&gt;
&lt;li&gt;比特币核心技术&lt;/li&gt;
&lt;li&gt;以太坊核心技术&lt;/li&gt;
&lt;li&gt;Hyperledger Fabric 等联盟链学习了解&lt;/li&gt;
&lt;li&gt;Solidity 智能合约开发&lt;/li&gt;
&lt;li&gt;Web3 技术学习与实践&lt;/li&gt;
&lt;li&gt;IPFS、跨链等热门技术学习&lt;/li&gt;
&lt;li&gt;核心项目源码解读&lt;/li&gt;
&lt;li&gt;参与开源项目/项目实战&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>