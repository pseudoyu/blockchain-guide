<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Ethereum MPT(Merkle Patricia Tries) 详解 # 前言 # 最近接到了一个工作任务，将项目智能合约状态树中的数据结构从红黑树改为字典树，并对比一下两个数据结构的性能，Trie 主要参照的是 Ethereum 官方的 Java 实现 ethereum/ethereumj，而红黑树则是自己实现，本文则是对两个数据结构的理论和实际表现对比的记录。
数据结构 # Red-Black Tree - 红黑树 # 红黑树是一种近似平衡的二叉查找树，含有红黑结点，能够确保任何一个结点的左右子树高度差小于两倍。
性质 # 必须满足以下五个性质：
结点为红色或黑色 根结点为黑色 叶子结点（NIL）为黑色 每个红色节点的两个子结点为黑色 任意一个结点到每个叶子结点的路径都包含相同数量的黑色结点 红黑树并不是完美平衡的，但是左子树和右子树的层数是相等的，因此，也成为黑色完美平衡。因为是近似平衡的，所以旋转的频次会降低，维护成本下降，时间复杂度维持在 LogN。
操作 # 红黑树主要通过三种操作来保持自平衡：
左旋 右旋 变色 与 AVL 的对比 # AVL 提供了更快的查找操作（因为完美平衡） 红黑树提供了更快的插入和删除操作 AVL 存储的结点信息更多（平衡因子与高度），因此占存储空间更大 读操作多、写操作少的时候用 AVL 更合适，多用于数据库；当写操作较多时一般使用红黑树，简洁好实现，多用于各类高级语言的库中，如 map、set 等 代码实现 # 因为红黑树较为复杂，实现代码上传至 GitHub 供学习查看。
pseudoyu/Red_Black_Tree_Java - GitHub
Trie - 字典树 # Trie 被称为字典树，又称单词查找树或键树，常用于统计和排序大量的字符串，如搜索引擎的文本磁盘统计等。
它能够最大限度减少无谓的字符串比较，查询效率较高。
性质 # 结点不存完整单词 从根结点到某一结点，路径上经过的字符连接起来为该结点对应的字符串 每个结点的所有子结点路径代表的字符都不相同 结点可以存储额外信息，如词频等 结点内部实现 # 字典树的高度较低，但占用的存储空间较大，核心思想是空间换时间。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://guide.pseudoyu.com/zh/docs/ethereum/blockchain_ethereum_mpt/"><meta property="og:site_name" content="区块链入门指南"><meta property="og:title" content="Ethereum MPT(Merkle Patricia Tries) 详解"><meta property="og:description" content="Ethereum MPT(Merkle Patricia Tries) 详解 # 前言 # 最近接到了一个工作任务，将项目智能合约状态树中的数据结构从红黑树改为字典树，并对比一下两个数据结构的性能，Trie 主要参照的是 Ethereum 官方的 Java 实现 ethereum/ethereumj，而红黑树则是自己实现，本文则是对两个数据结构的理论和实际表现对比的记录。
数据结构 # Red-Black Tree - 红黑树 # 红黑树是一种近似平衡的二叉查找树，含有红黑结点，能够确保任何一个结点的左右子树高度差小于两倍。
性质 # 必须满足以下五个性质：
结点为红色或黑色 根结点为黑色 叶子结点（NIL）为黑色 每个红色节点的两个子结点为黑色 任意一个结点到每个叶子结点的路径都包含相同数量的黑色结点 红黑树并不是完美平衡的，但是左子树和右子树的层数是相等的，因此，也成为黑色完美平衡。因为是近似平衡的，所以旋转的频次会降低，维护成本下降，时间复杂度维持在 LogN。
操作 # 红黑树主要通过三种操作来保持自平衡：
左旋 右旋 变色 与 AVL 的对比 # AVL 提供了更快的查找操作（因为完美平衡） 红黑树提供了更快的插入和删除操作 AVL 存储的结点信息更多（平衡因子与高度），因此占存储空间更大 读操作多、写操作少的时候用 AVL 更合适，多用于数据库；当写操作较多时一般使用红黑树，简洁好实现，多用于各类高级语言的库中，如 map、set 等 代码实现 # 因为红黑树较为复杂，实现代码上传至 GitHub 供学习查看。
pseudoyu/Red_Black_Tree_Java - GitHub
Trie - 字典树 # Trie 被称为字典树，又称单词查找树或键树，常用于统计和排序大量的字符串，如搜索引擎的文本磁盘统计等。
它能够最大限度减少无谓的字符串比较，查询效率较高。
性质 # 结点不存完整单词 从根结点到某一结点，路径上经过的字符连接起来为该结点对应的字符串 每个结点的所有子结点路径代表的字符都不相同 结点可以存储额外信息，如词频等 结点内部实现 # 字典树的高度较低，但占用的存储空间较大，核心思想是空间换时间。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Ethereum MPT(Merkle Patricia Tries) 详解 | 区块链入门指南</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/zh.search.min.de78ca7b5e96bed7be7f2f094cd5186899c81e7f7d8bb6a066872e5cd7adfcfa.js integrity="sha256-3njKe16Wvte+fy8JTNUYaJnIHn99i7agZocuXNet/Po=" crossorigin=anonymous></script><script data-goatcounter=https://stats-guide.pseudoyu.com/count async src=//stats-guide.pseudoyu.com/count.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>区块链入门指南</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/zh/docs/study_path/>学习路径</a></li></ul></li><li><p><strong>基础知识</strong></p><ul><li><a href=/zh/docs/blockchain/blockchain_basic/>区块链基础知识与关键技术</a></li><li><a href=/zh/docs/bitcoin/blockchain_bitcoin_basic/>比特币核心技术解读</a></li><li><a href=/zh/docs/ethereum/blockchain_ethereum_basic/>Ethereum 核心技术解读</a></li><li><a href=/zh/docs/ethereum/blockchain_ethereum_mpt/ class=active>Ethereum MPT 详解</a></li><li><a href=/zh/docs/solidity/learn_solidity_from_scratch_basic/>Solidity 智能合约开发 - 基础</a></li><li><a href=/zh/docs/solidity/learn_solidity_from_scratch_web3py/>Solidity 智能合约开发 - 玩转 Web3.py</a></li><li><a href=/zh/docs/solidity/learn_solidity_from_scratch_ethersjs/>Solidity 智能合约开发 - 玩转 ethers.js</a></li><li><a href=/zh/docs/solidity/learn_solidity_from_scratch_hardhat/>Solidity 智能合约开发 - Hardhat 框架使用</a></li><li><a href=/zh/docs/solidity/two_phase_commit_contract_practice_in_solidity/>通过状态锁在 Solidity 智能合约中实现两阶段提交</a></li><li><a href=/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_structure/>Fabric 系统架构详解</a></li><li><a href=/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_network/>Fabric 网络与安全体系浅析</a></li><li><a href=/zh/docs/hyperledger_fabric/blockchain_hyperledger_fabric_gosdk_event/>Fabric Go SDK 事件分析</a></li></ul></li><li><p><strong>热门技术</strong></p><ul><li><a href=/zh/docs/ipfs/blockchain_ipfs_structure/>IPFS 技术分析与思考</a></li><li><a href=/zh/docs/ipfs/blockchain_ipfs_practice/>IPFS 本地节点搭建</a></li><li><a href=/zh/docs/crosschain/blockchain_crosschain/>跨链技术原理与实战</a></li><li><a href=/zh/docs/baas/blockchain_baas_platform/>区块链服务平台 (BaaS) 简介</a></li></ul></li><li><p><strong>开发实战</strong></p></li><li><p><strong>附录：资源</strong></p></li><li><p><a href=https://github.com/pseudoyu/blockchain-guide><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Ethereum MPT(Merkle Patricia Tries) 详解</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#red-black-tree---红黑树>Red-Black Tree - 红黑树</a></li><li><a href=#trie---字典树>Trie - 字典树</a></li><li><a href=#modified-merkle-patricia-tries>Modified Merkle Patricia Tries</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></aside></header><article class=markdown><h1 id=ethereum-mptmerkle-patricia-tries-详解>Ethereum MPT(Merkle Patricia Tries) 详解
<a class=anchor href=#ethereum-mptmerkle-patricia-tries-%e8%af%a6%e8%a7%a3>#</a></h1><h2 id=前言>前言
<a class=anchor href=#%e5%89%8d%e8%a8%80>#</a></h2><p>最近接到了一个工作任务，将项目智能合约状态树中的数据结构从红黑树改为字典树，并对比一下两个数据结构的性能，Trie 主要参照的是 Ethereum 官方的 Java 实现 <a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj</a>，而红黑树则是自己实现，本文则是对两个数据结构的理论和实际表现对比的记录。</p><h2 id=数据结构>数据结构
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><h3 id=red-black-tree---红黑树>Red-Black Tree - 红黑树
<a class=anchor href=#red-black-tree---%e7%ba%a2%e9%bb%91%e6%a0%91>#</a></h3><p>红黑树是一种近似平衡的二叉查找树，含有红黑结点，能够确保任何一个结点的左右子树高度差小于两倍。</p><p><img src=https://image.pseudoyu.com/images/red_black_tree_2.png alt=red_black_tree_2></p><h4 id=性质>性质
<a class=anchor href=#%e6%80%a7%e8%b4%a8>#</a></h4><p>必须满足以下五个性质：</p><ol><li>结点为红色或黑色</li><li>根结点为黑色</li><li>叶子结点（NIL）为黑色</li><li>每个红色节点的两个子结点为黑色</li><li>任意一个结点到每个叶子结点的路径都包含相同数量的黑色结点</li></ol><p>红黑树并不是完美平衡的，但是左子树和右子树的层数是相等的，因此，也成为黑色完美平衡。因为是近似平衡的，所以旋转的频次会降低，维护成本下降，时间复杂度维持在 LogN。</p><h4 id=操作>操作
<a class=anchor href=#%e6%93%8d%e4%bd%9c>#</a></h4><p>红黑树主要通过三种操作来保持自平衡：</p><ul><li>左旋</li><li>右旋</li><li>变色</li></ul><h4 id=与-avl-的对比>与 AVL 的对比
<a class=anchor href=#%e4%b8%8e-avl-%e7%9a%84%e5%af%b9%e6%af%94>#</a></h4><ul><li>AVL 提供了更快的查找操作（因为完美平衡）</li><li>红黑树提供了更快的插入和删除操作</li><li>AVL 存储的结点信息更多（平衡因子与高度），因此占存储空间更大</li><li>读操作多、写操作少的时候用 AVL 更合适，多用于数据库；当写操作较多时一般使用红黑树，简洁好实现，多用于各类高级语言的库中，如 map、set 等</li></ul><h4 id=代码实现>代码实现
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0>#</a></h4><p>因为红黑树较为复杂，实现代码上传至 GitHub 供学习查看。</p><p><a href=https://github.com/pseudoyu/Red_Black_Tree_Java>pseudoyu/Red_Black_Tree_Java - GitHub</a></p><h3 id=trie---字典树>Trie - 字典树
<a class=anchor href=#trie---%e5%ad%97%e5%85%b8%e6%a0%91>#</a></h3><p>Trie 被称为字典树，又称单词查找树或键树，常用于统计和排序大量的字符串，如搜索引擎的文本磁盘统计等。</p><p>它能够最大限度减少无谓的字符串比较，查询效率较高。</p><p><img src=https://image.pseudoyu.com/images/trie_structure.png alt=trie_structure></p><h4 id=性质-1>性质
<a class=anchor href=#%e6%80%a7%e8%b4%a8-1>#</a></h4><ol><li>结点不存完整单词</li><li>从根结点到某一结点，路径上经过的字符连接起来为该结点对应的字符串</li><li>每个结点的所有子结点路径代表的字符都不相同</li><li>结点可以存储额外信息，如词频等</li></ol><h4 id=结点内部实现>结点内部实现
<a class=anchor href=#%e7%bb%93%e7%82%b9%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0>#</a></h4><p><img src=https://image.pseudoyu.com/images/trie_nodes.png alt=trie_nodes></p><p>字典树的高度较低，但占用的存储空间较大，核心思想是空间换时间。</p><p>利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的，可以很天然地解决单词联想等业务场景。</p><h4 id=代码实现-1>代码实现
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Trie</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Trie<span style=color:#f92672>[]</span> children;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> isEnd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Trie</span>() {
</span></span><span style=display:flex><span>        children <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Trie<span style=color:#f92672>[</span>26<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        isEnd <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(String word) {
</span></span><span style=display:flex><span>        Trie node <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> word.<span style=color:#a6e22e>length</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span> ch <span style=color:#f92672>=</span> word.<span style=color:#a6e22e>charAt</span>(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node.<span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                node.<span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Trie();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> node.<span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>index<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        node.<span style=color:#a6e22e>isEnd</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>search</span>(String word) {
</span></span><span style=display:flex><span>        Trie node <span style=color:#f92672>=</span> searchPrefix(word);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> node.<span style=color:#a6e22e>isEnd</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>startsWith</span>(String prefix) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> searchPrefix(prefix) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Trie <span style=color:#a6e22e>searchPrefix</span>(String prefix) {
</span></span><span style=display:flex><span>        Trie node <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> prefix.<span style=color:#a6e22e>length</span>(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span> ch <span style=color:#f92672>=</span> prefix.<span style=color:#a6e22e>charAt</span>(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (node.<span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> node.<span style=color:#a6e22e>children</span><span style=color:#f92672>[</span>index<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=modified-merkle-patricia-tries>Modified Merkle Patricia Tries
<a class=anchor href=#modified-merkle-patricia-tries>#</a></h3><h4 id=以太坊账户状态存储方式>以太坊账户状态存储方式
<a class=anchor href=#%e4%bb%a5%e5%a4%aa%e5%9d%8a%e8%b4%a6%e6%88%b7%e7%8a%b6%e6%80%81%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f>#</a></h4><ol><li>使用 Key-Value 的哈希表存储在每次出块时都会有新交易打包进块中，从而改变 merkle tree，但事实上只有一小部分账户发生改变，成本过高</li><li>直接用 merkle tree 存放账户，要改内容时直接改 merkle tree 也不可行，因为 merkle tree 没有提供一个高校的查找和更新方法</li><li>使用 sorted merkle tree 也不可行，因为新增账户产生的账户地址是随机的，需要插入重新排序</li></ol><h4 id=mpt-结构>MPT 结构
<a class=anchor href=#mpt-%e7%bb%93%e6%9e%84>#</a></h4><p>利用了 Trie 结构的特点</p><ol><li>打乱顺序后 Trie 结构不变，天然排序，即使插入新值也不影响，适用于以太坊 account-base 的结构</li><li>具有很好的更新局部性，更新时不用遍历整棵树</li></ol><p>但是 Trie 结构比较浪费存储空间，当键值对分布稀疏时效率较低，而以太坊的账户地址是 40 位十六进制数，地址约为 2^160 种，极其稀疏（防止哈希碰撞）。</p><p>因此，需要对 Trie 结构进行路径压缩，也就是 Pactricia Trie，经过压缩后，树的高度明显减少，空间和效率都得到提升。</p><p><img src=https://image.pseudoyu.com/images/pactricia_trie.png alt=pactricia_trie></p><h4 id=modified-mpt-结构>Modified MPT 结构
<a class=anchor href=#modified-mpt-%e7%bb%93%e6%9e%84>#</a></h4><p>而以太坊真正采用的是 Modified MPT 结构，其结构如下</p><p><img src=https://image.pseudoyu.com/images/modified_merkle_pactricia_trie.png alt=modified_merkle_pactricia_trie></p><p>每次发布新的区块时，状态树中的新节点的值会发生变化，并不是更改原值，而是新建一些分支，保留原来的状态（因此可以实现回滚）。</p><p>在以太坊系统中，分叉是常态，orphan block 中的数据都要向前回滚，而由于 ETH 中有智能合约，为了支持智能合约的回滚，必须保持之前的状态。</p><h4 id=代码实现-2>代码实现
<a class=anchor href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2>#</a></h4><p>代码参照以太坊的 Java 实现。</p><p><a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj - GitHub</a></p><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>以上就是对<code>Ethereum MPT</code> 与红黑树数据结构的解析，在刷 LeetCode 痛苦的时候想过很多次这些学了也用不到，没想到那么快就有了应用场景，还是要好好理解和实践呀！</p><h2 id=参考资料>参考资料
<a class=anchor href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>#</a></h2><blockquote><ol><li><a href=https://www.jianshu.com/p/e136ec79235c>30 张图带你彻底理解红黑树</a></li><li><a href=https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/>LeetCode 实现 Trie</a></li><li><a href=https://github.com/pseudoyu/Red_Black_Tree_Java>pseudoyu/Red_Black_Tree_Java</a></li><li><a href=https://segmentfault.com/a/1190000016050921>以太坊源码分析 &ndash; MPT 树</a></li><li><a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj</a></li></ol></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#red-black-tree---红黑树>Red-Black Tree - 红黑树</a></li><li><a href=#trie---字典树>Trie - 字典树</a></li><li><a href=#modified-merkle-patricia-tries>Modified Merkle Patricia Tries</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></aside></main></body></html>